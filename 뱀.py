'''
뱀 (1/93) / 2025-03-05 / 체감 난이도 : 골드 4
소요 시간 : 1시간 30분 / 시도 : 1회 / 실행 시간 : 124ms / 메모리 : 114332KB

[타임라인]
1. 문제이해 & 구상 & sudo code 작성 (20분)
2. 구현 (10분)
3. 디버깅 (30분) -> 오픈 테케가 틀렸다
 꼬리가 없어지는 방향에 대한 관리를 아예 잘못 하고 있었음
관리를 따로 해줘야겠다는 걸 문제 읽을 때 생각하지 못함..
4.아예 다시 구현했는데 또 틀려서 또 디버깅 (20분)
(여전히 잘못 관리했음,
내가 도착했을 때 방향을 기록하는게 아니라 다음으로 갈 때 사용한 방향을 기록했어야 함
하나 전 방향을 어떻게 기록하지..? -> 이동 전에 기록하면 됨 = 즉 나를 기준으로는 기록하고 다음으로 가면 됨 )

[디버깅 내역]
- 직접 뱀 배열을 찍어보면서 꼬리 관리가 안 된다는 것을 반견
bam[si][sj] = (1,dr) <- 여기서 해야
si, sj = ni, nj <- 이 뒤에서 하면 안됨

[시간복잡도 계산]
겹치기 전까지 계속 도는 거니까
최대 100*100

[후기]
나는 배열을 이동하면서 si,sj (머리), ei,ej (꼬리)를 추적했고 꼬리를 하나 없앨 때 그 위치에서 다음 위치로 간 방향까지 기록해줬는데,
걍 준영 프로님 코드처럼 좌표를 따로 관리해주면 아주 편함
" 뱀의 시작과 끝이 자주 변동하기 떄문에 deque을 써야 한다고 생각했고 " 요렇게 .. 자료구조에 대한 생각 좀 해 !!!

아 그리고 time 도 걍 앞에서 +1 해주면 됨

'''

from collections import deque

# 보드의 크기 N (2 ≤ N ≤ 100)
N=int(input())

# arr에 사과가 있는 곳은 1, 없는 곳은 0으로 표시
arr=[[0]*N for _ in range(N)]

# 사과의 개수 K (0 ≤ K ≤ 100)
K=int(input())
for _ in range(K):
    r,c=map(int,input().split())
    r,c=r-1,c-1
    arr[r][c]=1

L=int(input())
q=deque()
for _ in range(L):
    t,d=input().split()
    t=int(t)
    q.append((t,d))

# 초기값
di=[0,1,0,-1]
dj=[1,0,-1,0]
dr=0

# 뱀을 표시하는 배열로 뱀이 있는 자리에 (1, 방향)으로 표시
# 단, 방향을 내가 다음 거로 갈 때 사용한 방향을 적어야 함
bam=[[0]*N for _ in range(N)]

# 각각 머리 좌표, 꼬리 좌표
si,sj,ei,ej=0,0,0,0

# 몇초 걸렸는지
time=0

while True:
    # 오름차순 정렬되어 있으니 확인하면 pop하기
    if q and time == q[0][0]:
        a, b = q.popleft()
        if b == "L":
            dr = (dr - 1) % 4

        elif b == "D":
            dr = (dr + 1) % 4

    # [1] 머리 다음 칸으로
    ni, nj = si + di[dr], sj + dj[dr]

    # 종료조건
    if ni < 0 or ni >= N or nj < 0 or nj >= N or bam[ni][nj] !=0:
        # 마지막에서 time을 더하지만 어쨌든 여기까지 온 것도 다음 time을 한 거니까
        # 마지막에 추가
        print(time+1)
        break
    else:
        # si,sj를 바꿔주기 전에 옮기기 전 머리 위치에 써주고
        bam[si][sj] = (1,dr)
        # 바꾼다
        si, sj = ni, nj

    # [2] 사과가 있으면 먹어
    if arr[si][sj] == 1:
        arr[si][sj] = 0

    else:
        # 사과 가 없으면 꼬리를 비워
        _,e_dr=bam[ei][ej]
        bam[ei][ej]=0
        ei, ej = ei + di[e_dr], ej + dj[e_dr]

    # 시간 하나 추가 !
    # ex ) 1초가 끝난게 여기서 표시 되니까 위에 가서 확인 하면 됨
    time += 1
